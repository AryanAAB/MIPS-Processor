.data
    prompt:     .asciiz "Enter the radius (integer): "
    resultMsg:  .asciiz "Number of integer points inside the circle: "

.text
    main:
        # Print prompt and read radius
        li $v0, 4               # syscall: print_str
        la $a0, prompt          # load address of prompt
        syscall

        li $v0, 5               # syscall: read_int
        syscall
        move $s0, $v0           # store radius in $s0

        # Call function countIntegerPointsInsideCircle
        move $a0, $s0           # pass radius as argument
        jal countIntegerPointsInsideCircle

        # Print result message and the count
        li $v0, 4               # syscall: print_str
        la $a0, resultMsg       # load address of resultMsg
        syscall

        move $a0, $v0           # pass count as argument
        li $v0, 1               # syscall: print_int
        syscall

        # Exit program
        li $v0, 10              # syscall: exit
        syscall

countIntegerPointsInsideCircle:
        # Function to count integer points inside the circle
        # Arguments: $a0 (radius)
        # Returns: $v0 (count)

        li $t0, 0               # initialize count to 0
        li $t1, 1               # initialize x to 1

    loop_x:
        ble $t1, $a0, check_y   # if x > radius, exit loop

        li $t2, 0               # initialize y to 0
        move $t3, $t1           # copy x to $t3

    loop_y:
        bge $t2, 0, increment_y # if y >= 0, check condition and increment y

        # Check condition: x^2 + y^2 < radius^2
        mul $t4, $t3, $t3       # x^2
        mul $t5, $t2, $t2       # y^2
        add $t6, $t4, $t5       # x^2 + y^2
        mul $t7, $a0, $a0       # radius^2

        bge $t6, $t7, decrement_y  # if x^2 + y^2 >= radius^2, decrement y

        # Increment count: c += y + 1
        addi $t0, $t0, 1
        addi $t2, $t2, 1
        j loop_y

    decrement_y:
        subi $t2, $t2, 1

    increment_y:
        addi $t2, $t2, 1

    check_y:
        blt $t2, $a0, loop_y    # if y < radius, repeat loop_y
        addi $t1, $t1, 1        # increment x
        j loop_x

    exit_function:
        move $v0, $t0           # return count in $v0
        jr $ra                  # return to caller
